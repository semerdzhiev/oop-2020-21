# Binary Files & Templates

[Запис](https://drive.google.com/file/d/1SU-I3yg9Thmeu2sY3tJnm7SE-B_ov1Mm/view?usp=sharing)

Припомнете си какво правихме за наследяване преди време ^.^


## Binary Files

За да отворим файл в двоичен режим използваме флага `std::ios::binary`.

Двоичните файлове си представяйте като съвкупност от байтове. Можем да четем/пишем поредица от байтове (`char` е тип с размер 1 байт -> поредица от байтове е масив от байтове -> `char*`) и да ги cast-ваме към наши типове. 
Пример:

```c++
struct A3ByteStruct
{
    uint8_t a;
    uint8_t b;
    uint8_t c;
};

// sizeof(A3ByteStruct) == 3

...

std::ifstream in(file_name, std::ios::binary | std::ios::in);
A3ByteStruct obj;
in.read(reinterpret_cast<const char*>(&obj), sizeof(A3ByteStruct));

```

## Templates

Темплейтите (шаблоните) използваме, когато искаме да подадем типа да данните, за да не пишем един и същи код за различни типове данни.

Може да ги използваме при функции: 

```c++
template <typename T>
T min(T x, T y) 
{
  if(x > y)
    return y;
  return x;
}
```

и класове: 

```c++
template <typename T> 
class A 
{
  T element;
public:
  A(T element);
}

template <typename T>
A<T>:: A(T element)
{
  this->element = element;
}

```

Можем да добавяме повече от един тип към темплейта:

```c++
template <typename T, typename U> 
class A 
{
  T element;
  U anotherElement;
public:
  A(T element, U anotherElement);
}

```

А можем и да дадем стойност по подразбиране на аргумента:

```c++
template <typename T, typename U = int> 
class A 
{
  T element;
  U anotherElement;
public:
  A(T element, U anotherElement);
}
```

## Задача 1

От командния ред се подава име на изображение в `bmp` формат. Конвертирайте изображението в grayscale. 

Използваме следната формула за конвертиране на RGB пиксел до Grayscale такъв:

`Color = 0.21*Red + 0.72*Green + 0.07*Blue`

`BMP` изображенията имат следния формат:

### Метаданни
Тези които ни трябват на нас са:
- От позиция 2 - 4 байта - размер на файла (в байтове) (`size`)
- От позиция 10 - 4 байта - позиция, на която започва съдържанието на изображението (`start`)
- От позиция 18 - 4 байта - ширина на изображението (`columns`)
- От позиция 22 - 4 байта - височина на изображението (`rows`)

### Съдържание на изображението
Започвайки от позиция `start`:
- имаме `rows` реда
- всеки ред има `columns` пиксела
- всеки пиксел се състои от 3 байта - синьо, зелено, червено (стойности между 0 и 255)
- всеки ред има padding, така че броя на байтовете в реда да се дели на 4 (всичко от padding-а се игнорира при визуализиране на изображението)

## Задача 2
Реализирайте собствен шаблонен клас Vector.
Той трябва да се инициализира с капацитет 1 и да се преоразмерява 2 пъти, когато капацитета му свърши.
Трябва да реализира методите от Ro3 / Ro5
Трябва да има следните методи:
- `push_back` - добавя елемент в края
- `pop_back` - премахва елемент в края
- `size` - връща броя на елементите във вектора
- `capacity` - връща капацитета на вектора
- `empty` - проверява дали вектора е празен
- `operator[]` - достъпва елемент на позиция (константна и неконстантна версия)
- `clear` - изтрива съдържанието на вектора
